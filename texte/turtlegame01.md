# Spieleprogrammierung mit Pythons Turtle-Modul (Teil 1)

Angeregt durch die Video-Tutorial-Reihe Â»[Simple Python Game Tutorial Using Classes](https://www.youtube.com/watch?v=sSKXVy3L-HY&list=PLlEgNdBJEO-lwI_F15DAQmgmqh5E7OYt_)Â« von *[Christian Thompson](http://christianthompson.com/node/5)*, einem in Japan lebenden und lehrenden Amerikaner, wollte ich auch einmal ausprobieren, wie einfach oder wie schwer es ist, mit Pythons [Turtle Bibliothek](https://docs.python.org/3.3/library/turtle.html?highlight=turtle), die Teil der mitgeliederten Standard-Bibliotheken von Pyhon ist, ein Spiel zu programmieren. Ich habe mich dabei weitestgehend an obige Video-Tutorial-Reihe angelehnt, jedoch einiges geÃ¤ndert, was einmal durch unterschiedliche Programmierstile begrÃ¼ndet ist, auf der anderen Seite habe ich auch einige Fehlerchen beseitigt und Ungereimtheiten ausgerÃ¤umt.

[![Screenshot01](images/turtlegame01.jpg)](https://www.flickr.com/photos/schockwellenreiter/37927158045/)

Als erstes habe ich natÃ¼rlich das Modul `turtle` importiert und dann ein paar Initialisierungen vorgenommen:

~~~python
import turtle as t

WIDTH = 600
HEIGHT = 600

wn = t.Screen()
wn.bgcolor("black")
wn.setup(width = WIDTH, height = HEIGHT)
wn.title("Turtle Graphics Game Tutorial â€“ Stage 1")
~~~

Die HÃ¶he und die Weite des Spielefenster habe ich ganz oben als Konstanten festgeschrieben. Alle spÃ¤teren AbhÃ¤ngigkeiten wie zum Beispiel der weiÃŸe Spielfeldrand oder das Checken der RÃ¤nder durch die Spielfigur(en) habe ich von diesen Konstanten abgeleitet. Wenn also die GrÃ¶ÃŸe des Spielfeldes geÃ¤ndert werden soll, mÃ¼ssen nur diese beiden Konstanten geÃ¤ndert werden, alle anderen notwendigen Ã„nderungen erledigt dann das Programm automatisch.

Dann gibt es eine Klasse `Sprite`, die die Oberklasse fÃ¼r alle beweglichen Elemente in diesem Spiel ist. Sie erbt von `Turtle` und folgerichtig muÃŸ der Konstruktor von `Sprite` auch den Konstruktor von `Turtle`aufrufen. Daneben gibt es noch eine Methode `move()`, die aber nur als Platzhalter dient, zu Testzwecken von mir implementiert wurde und in der Regel von der Unterklasse Ã¼berschrieben wird:

~~~python
class Sprite(t.Turtle):
    
    def __init__(self, tshape, tcolor):
        t.Turtle.__init__(self)
        self.penup()
        self.shape(tshape)
        self.color(tcolor)
        self.speed = 1
        self.max_speed = 10
    
    def move(self):
        self.forward(self.speed)
~~~

Der Konstruktor von `Sprite`bekommt als Argumente den *Shape*, also die Form des Sprites und die Farbe des Sprites mitgeliefert, die dort initialisiert werden. Die Spielfigur, also die *Turtle* oder der *[Sprite](https://de.wikipedia.org/wiki/Sprite_(Computergrafik))*, soll sich bewegen, ohne eine Spur zu hinterlassen, daher wird der Stift bei der Initialisierung angehoben (`penup`). Eine Default-Startgeschwindigkeit und eine Maximalgeschwindigkeit wird dort ebenfalls noch vereinbart.

Die nÃ¤chste Klasse, die im Code vereinbart wird, ist `GameWorld`, deren einzige Instanz in diesem Programm nur die Aufgabe hat, die Grenzen des Spielfeldes zu zeichnen. Auch diese Klasse ist natÃ¼rlich eine Unterklasse von `Turtle`:

~~~python
class GameWorld(t.Turtle):
    
    def __init__(self):
        t.Turtle.__init__(self)
        self.penup()
        self.hideturtle()
        self.speed(0)
        self.color("white")
        self.pensize(5)
    
    def draw_border(self):
        self.penup()
        self.goto(-WIDTH/2 + 40, -HEIGHT/2 + 40)
        self.pendown()
        self.goto(-WIDTH/2 + 40, HEIGHT/2 - 40)
        self.goto(WIDTH/2 - 40, HEIGHT/2 - 40)
        self.goto(WIDTH/2 - 40, -HEIGHT/2 + 40)
        self.goto(-WIDTH/2 + 40, -HEIGHT/2 + 40)
~~~

`GameWorld` bekommt bei der Initialisierung keine Paramter mitgeliefert, also kann und braucht sie auch der Oberklasse keine mitzuteilen. Auch diese Turtle soll zu Beginn -- alle Turtle starten per Default in der Mitte des Fensters -- keine Spur ziehen (das wÃ¤re ja sonst eine halbe Diagonale), daher wird auch hier der Stift erst einmal hochgesetzt. AuÃŸerdem soll sie auch nicht sichtbar sein, dies wird mit der Methode `hideturtle()`erreicht. Mit `speed(0)` wird fÃ¼r die Turtlewelt die hÃ¶chstmÃ¶gliche Animationsgeschwindigkeit vereinbart [^tg0101]. Dies wird im Weiteren nicht ausreichend sein (eine SchildkrÃ¶te ist schlieÃŸlich kein Rennpferd), wie man die AusfÃ¼hrungsgeschwindigkeit noch besser beschleunigen und steuern kann, werde ich in einem spÃ¤teren Tutorial erklÃ¤ren. Aber fÃ¼r diese erste Version reicht dies erst einmal aus.

[^tg0101]: Die Methode `speed(x)` ist nicht mit der Variable `speed = x` zu verwechseln, das sind zwei vÃ¶llig unabhÃ¤ngige Elemente.

Die Farbe des Randes soll weiÃŸ sein und er soll eine Breite von 5 Pixeln haben.

Dann wird die Turtle in der Methode `draw_border()` angewiesen, den Rand zu zeichnen. Sicherheitshalber habe ich den Stift noch einmal angehoben, bevor ich die SchildkrÃ¶te zum Startpunkt schicke. Von dort zeichnet sie dann in AbhÃ¤ngigkeit von den Konstanten `WIDTH` und `HEIGHT` ein Rechteck und hat dann ihre Aufgabe erledigt.

Nun wieder zu den Sprites: In diesem frÃ¼hen Stadium des Projekts besitzt `Sprite`nur eine Unterklasse, die ich `Actor` genannt habe.

~~~python
class Actor(Sprite):
    
    def __init__(self, tshape, tcolor):
        Sprite.__init__(self, tshape, tcolor)
    
    def move(self):
        self.forward(self.speed)

        # RÃ¤nder checken und ausweichen
        if self.xcor() >= WIDTH/2 - 60 or self.xcor() <= -WIDTH/2 + 60:
            self.forward(-self.speed)
            self.left(75)
        if self.ycor() >= HEIGHT/2 - 60 or self.ycor() <= -HEIGHT/2 + 60:
            self.forward(-self.speed)
            self.left(75)
    
    def turnleft(self):
        self.left(30)
    
    def turnright(self):
        self.right(30)
    
    def move_faster(self):
        self.speed += 1
        # Geschwindigkeitsbegrenzug
        if abs(self.speed) > self.max_speed:
            self.speed = self.max_speed
    
    def move_slower(self):
        # Geschwindigkeitsbegrenzung
        self.speed -= 1
        if abs(self.speed) > self.max_speed:
            self.speed = - self.max_speed
~~~

`Actor` erbt alle Eigenschaften von `Sprite`, daher muÃŸ der Konstruktor nur den Konstruktor von `Sprite`aufrufen. Die `move()`-Methode wird ziemlich erweitert, daher muÃŸte sie Ã¼berschrieben werden.

Der *Actor* bewegt sich erst einmal nach rechts, die RichtungsÃ¤nderungen erfolgen im Hauptprogramm mithilfe der Pfeiltasten. Der *Actor* soll selbststÃ¤ndig die Grenzen der Spielwelt erkennen und darauf reagieren. Das wurde in den folgenden Zeilen erledigt. StÃ¶ÃŸt die *Turtle* an die Grenzen (die wieder in AbhÃ¤ngigkeit von den Konstanten `WIDTH` und `HEIGHT` erkannt werden, dann soll sie erst einmal einen Schritt zurÃ¼ckgehen [^tg0102] und dann sich um 75Â° nach links drehen.

[^tg0102]: Der Schritt zurÃ¼ck ist notwendig, da sich sonst die *Turtle* bei der Wendug nach links wieder in der Grenze verfangen kann. Im Extremfall fÃ¤ngt sie dann an zu tanzen und entkommt entweder der Grenze gar nicht mehr oder fÃ¤llt sogar aus dem Spielfeld heraus. Es ist wie im wirklichen Leben: StÃ¶ÃŸt man auf ein Hindernis, erst einen Schritt zurÃ¼cktreten, dann sich umdrehen und abhauen.ğŸ˜œ

Die 75Â° habe ich willkÃ¼rlich gewÃ¤hlt, sie lassen die Bewegung des *Actors* Ã¼ber das Spielfeld weniger vorhersehbar erscheinen. Aber der Leser ist aufgefordert, mit anderen Winkeln zu experimentieren.

Die vier letzten Methoden sind die, mit denen Ã¼ber die Tastatur die Instanz des *Actors* in seinen Bewegungen gesteuert werden soll. Die linke und die rechte Pfeiltaste sollen die Figur jeweils um 30Â° nach links oder rechts bewegen, und mit den Pfeiltasten nach oben und unten soll die Figur beschleunig, respektive verlangsamt werden. Damit die Spielfigur nicht durch die Decke schieÃŸt wird in beiden Richtungen eine Maximalgeschwindigkeit festgelegt. Dabei kann es durchaus passieren, daÃŸ die Spielfigur sich rÃ¼ckwÃ¤rts bewegt -- das ist so gewollt.

Da ich wollte, daÃŸ das Spiel Â»ordentlichÂ« beendet und nicht einfach brutal durch das SchlieÃŸen des Spielefensters abgebrochen wird, habe ich noch eine globale Funktion `exitGame()` geschrieben. Diese Funktion soll aufgerufen werden, wenn der Spieler die `Escape`-Taste drÃ¼ckt:

~~~python
def exitGame():
    global keepGoing
    keepGoing = False
~~~

Jetzt sind alle Vorarbeiten geleistet und das Spiel kann beginnen. Dazu muÃŸ erst einmal der Spieler und die Spielwelt initialisiert werden:

~~~python
player = Actor("triangle", "red")
world = GameWorld()
world.draw_border()
~~~

Die Spielfigur `player` wird als eine Instanz der Klasse `Actor` in Form eines roten Dreiecks aufgerufen und die Spielewelt `world` ist eine Instanz der Klasse `GameWorld`. Und dieses Objekt zeichnet auch dann sofort die Grenzen der Spielwelt um sich dann fÃ¼r den Rest der Spieles schlafen zu legen. Sie hat ihre Schuldigkeit getan.

Was noch nicht erledigt ist, ist das Â»LauschenÂ« auf die Tastaturereignisse. Das sind direkte Methoden des Turtle-Moduls und sie werden als nÃ¤chstes aufgerufen:

~~~python
# Auf Tastaturereignisse lauschen
t.listen()
t.onkey(player.turnleft, "Left")
t.onkey(player.turnright, "Right")
t.onkey(player.move_faster, "Up")
t.onkey(player.move_slower, "Down")
t.onkey(exitGame, "Escape") # Escape beendet das Spiel
~~~

Als erstes wird ein Lauscher (engl. *listener*) initialisiert. Und dann werden die diversen *Callbacks* fÃ¼r die Pfeiltasten und die Escape-Taste instantiiert. Dabei verlangt die Methode `onkey()` als ersten Parameter den Namen der Funktion (ohne Klammern und Parameter) und als zweites den Namen der Taste [^tg0103], die diese Funktion aufrufen soll.

[^tg0103]: Die Namen der Tasten habe ich einem Tutorial zur Tkinter-Programmierung entnommen, denn auch das Turtle-Modul ist nur ein Wrapper um die Graphikfunktionen von *Tkinter*.

So, jetzt bleibt nur noch die eigentliche Spielschleife und die ist dank der umfangreichen Vorarbeit extrem kurz:

~~~python
# Spiel-Schleife
keepGoing = True
while keepGoing:
    player.move()
~~~

Zuerst wird die boolsche Variable `keepGoing` auf `True` gesetzt und dadurch mit `while keepGoing` eine Endlosschleife aufgerufen in der mit `player.move()` sich die Spielfigur druch die Welt bewegt. Erst wenn der Spieler die `Escape`-Taste drÃ¼ckt, wird `keepGoing` auf `False` gesetzt und somit die `while`-Schleife verlassen und das Spiel beendet.

Zur besseren Ãœberischt hier noch einmal das komplette Programm:

~~~python
import turtle as t

WIDTH = 600
HEIGHT = 600

wn = t.Screen()
wn.bgcolor("black")
wn.setup(width = WIDTH, height = HEIGHT)
wn.title("Turtle Graphics Game Tutorial â€“ Stage 1")

class Sprite(t.Turtle):
    
    def __init__(self, tshape, tcolor):
        t.Turtle.__init__(self)
        self.penup()
        self.shape(tshape)
        self.color(tcolor)
        self.speed = 1
        self.max_speed = 10
    
    def move(self):
        self.forward(self.speed)

class GameWorld(t.Turtle):
    
    def __init__(self):
        t.Turtle.__init__(self)
        self.penup()
        self.hideturtle()
        self.speed(0)
        self.color("white")
        self.pensize(5)
    
    def draw_border(self):
        self.penup()
        self.goto(-WIDTH/2 + 40, -HEIGHT/2 + 40)
        self.pendown()
        self.goto(-WIDTH/2 + 40, HEIGHT/2 - 40)
        self.goto(WIDTH/2 - 40, HEIGHT/2 - 40)
        self.goto(WIDTH/2 - 40, -HEIGHT/2 + 40)
        self.goto(-WIDTH/2 + 40, -HEIGHT/2 + 40)

class Actor(Sprite):
    
    def __init__(self, tshape, tcolor):
        Sprite.__init__(self, tshape, tcolor)
    
    def move(self):
        self.forward(self.speed)

        # RÃ¤nder checken und ausweichen
        if self.xcor() >= WIDTH/2 - 60 or self.xcor() <= -WIDTH/2 + 60:
            self.forward(-self.speed)
            self.left(75)
        if self.ycor() >= HEIGHT/2 - 60 or self.ycor() <= -HEIGHT/2 + 60:
            self.forward(-self.speed)
            self.left(75)
    
    def turnleft(self):
        self.left(30)
    
    def turnright(self):
        self.right(30)
    
    def move_faster(self):
        self.speed += 1
        # Geschwindigkeitsbegrenzug
        if abs(self.speed) > self.max_speed:
            self.speed = self.max_speed
    
    def move_slower(self):
        # Geschwindigkeitsbegrenzung
        self.speed -= 1
        if abs(self.speed) > self.max_speed:
            self.speed = - self.max_speed

player = Actor("triangle", "red")
world = GameWorld()
world.draw_border()

def exitGame():
    global keepGoing
    keepGoing = False

# Auf Tastaturereignisse lauschen
t.listen()
t.onkey(player.turnleft, "Left")
t.onkey(player.turnright, "Right")
t.onkey(player.move_faster, "Up")
t.onkey(player.move_slower, "Down")
t.onkey(exitGame, "Escape") # Escape beendet das Spiel

# Spiel-Schleife
keepGoing = True
while keepGoing:
    player.move()
~~~

Probiert es aus. Das rote Dreieck bewegt sich -- von Euch gesteuert -- Ã¼ber das Spielfeld, ohne je Ã¼ber die Grenzen hinauszuschieÃŸen. Dem ist anfangs interessiert zuzuschauen, aber auf Dauer ist es doch etwas langweilig. Daher mÃ¶chte ich im nÃ¤chsten Tutorial der Spielfigur ein paar Ziele spendieren, die ihr Punkte einbringen, damit auch der Spieler ein Ziel (mÃ¶glichst viele Punkte sammeln) bekommt.